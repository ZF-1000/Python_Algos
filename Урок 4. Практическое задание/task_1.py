"""
1. Проанализировать скорость и сложность одного любого алгоритма,
разработанных в рамках домашнего задания первых трех уроков.
Примечание: попробуйте написать несколько реализаций алгоритма и сравнить их.

Подсказка:
1) возьмите 2-3 задачи, реализованные ранее, сделайте замеры на разных входных данных
2) сделайте для каждой из задач оптимизацию (придумайте что можно оптимизировать)
и также выполните замеры на уже оптимизированных алгоритмах
3) опишите результаты - где, что эффективнее и почему.

ВНИМАНИЕ: ЗАДАНИЯ, В КОТОРЫХ БУДУТ ГОЛЫЕ ЦИФРЫ ЗАМЕРОВ (БЕЗ АНАЛИТИКИ)
БУДУТ ПРИНИМАТЬСЯ С ОЦЕНКОЙ УДОВЛЕТВОРИТЕЛЬНО
"""

import timeit
import cProfile
import time

'''
Анализ скорости и сложности алгоритма определения сколько из диапазона натуральных
числе [2, 100000) кратны каждому из чисел в диапазоне [2, 10)
'''

'''
Реализация №1. Вложенный цикл. Здесь имеет место квадратичная сложность # O(n^2).
'''

print(f'\nЗамер выполнения кода через вложенный цикл')
print('Метод <<timeit>>')

STR_CODE_1 = '''
from_numb = 2
to_numb = 10
from_range = 2
to_range = 100000

for i in range(from_numb, to_numb):
    flag = 0
    for j in range(from_range, to_range):
        if j % i == 0:
            flag += 1
'''

LAUNCH_LST = [1, 10, 100, 1000]  # массив запусков программы
for i in LAUNCH_LST:
    print(f'Число запусков кода = {i}. ', end='')
    print(f'Время выполнения операции = {timeit.timeit(STR_CODE_1, number=i)}')

'''
Реализация №2. Функция.
'''

print(f'\nЗамер выполнения кода через функцию')
print('Метод <<timeit>>')


def cycle_method(items_1, items_2, output_str=''):
    '''Цикл'''
    for elem_1 in items_1:
        flag = 0
        for elem_2 in items_2:
            if elem_2 % elem_1 == 0:
                flag += 1
        output_str += f'В диапазоне {items_2[0:1]} - {items_2[-1:]}: {flag} чисел кратны \'{i}\'\n'
    return output_str


for i in LAUNCH_LST:
    print(f'Число запусков кода = {i}. Время выполнения операции = ', end=' ')
    print(
        timeit.timeit(
            'cycle_method(list(range(2, 10)), list(range(2, 100000)))',
            setup='from __main__ import cycle_method',
            number=i))

print('\nМетод <<cProfile>>')
cProfile.run('cycle_method(list(range(2, 10)), list(range(2, 100000)))')

'''
На данном примере просто посмотрел, как работают модули timeit и cProfile
Рассмотрел два варианта кода:
- решение через вложенный цикл. Здесь имеет место квадратичная сложность O(n^2)
- решение через функцию. Функция аналогична фрагменту кода через вложенный цикл

Метод timeit и cProfile показали эквивалентное время выполнения кода.
С ростом числа запусков кода время выполнения растёт пропорционально,
что и логично (никакой оптимизации кода нет)
'''

'''
Реализация подсчёта времени выполнения программы вручную (просто, как пример)
'''

START = time.time()

for i in range(2, 10):
    FLAG = 0
    for j in range(2, 100000):
        if j % i == 0:
            FLAG += 1
print(f'\nВремя выполнения программы (ручной замер): {time.time() - START} ')


'''
Результаты вычислений

Замер выполнения кода через вложенный цикл
Метод <<timeit>>
Число запусков кода = 1. Время выполнения операции = 0.223464768
Число запусков кода = 10. Время выполнения операции = 2.192130005
Число запусков кода = 100. Время выполнения операции = 20.938258309
Число запусков кода = 1000. Время выполнения операции = 189.561709845

Замер выполнения кода через функцию
Метод <<timeit>>
Число запусков кода = 1. Время выполнения операции =  0.14114100699998744
Число запусков кода = 10. Время выполнения операции =  1.8089432919999808
Число запусков кода = 100. Время выполнения операции =  17.963720346000002
Число запусков кода = 1000. Время выполнения операции =  215.73111694

Метод <<cProfile>>
         4 function calls in 0.169 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.006    0.006    0.169    0.169 <string>:1(<module>)
        1    0.164    0.164    0.164    0.164 task_1.py:58(cycle_method)
        1    0.000    0.000    0.169    0.169 {built-in method builtins.exec}
        1    0.000    0.000    0.000    0.000 {method 'disable' of '_lsprof.Profiler' objects}


Время выполнения программы (ручной замер): 0.3460197448730469 
'''
